//
//  SmartCardKey.swift
//  PGPro
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.

import Foundation

class SmartCardKey {

    var status: KeyStatus?
    var fingerprint: Fingerprint?
    var userInteractionFlag: UserInteractionFlag?
    var algorithmAttributes: AlgorithmAttributes?

    enum KeyStatus: UInt8 {
        case keyNotPresent  = 0x00
        case keyGenerated   = 0x01
        case keyImported    = 0x02

        var description: String {
            switch self {
            case .keyNotPresent: return "Key not present"
            case .keyGenerated: return "Key generated by the card"
            case .keyImported: return "Key imported into the card"
            }
        }
    }

    struct Fingerprint {
        private var value: Data

        var description: String {
            return value.hexEncodedString.uppercased().insertSeparator(" ", atEvery: 4)
        }

        init?(from data: Data) {
            // Fail if all bytes are zero
            if data.allSatisfy({ dataByte in dataByte == 0 }) {
                return nil
            }

            self.value = data
        }

    }

    enum UserInteractionFlag: UInt8 {
        case disabled           = 0x00 // default
        case enabled            = 0x01
        case permanentlyEnabled = 0x02
    }

    class AlgorithmAttributes {
        var algorithmID: AlgorithmAttributesID?
        enum AlgorithmAttributesID: UInt8 {
            case RSA    = 0x01 // RSA (RFC 4880) for Encrypt or Sign
            case ECDSA  = 0x13 // ECDSA for PSO:CDS and INT-AUT
            case ECDH   = 0x12 // ECDH for PSO:DEC

            var description: String {
                switch self {
                case .RSA: return "RSA"
                case .ECDSA: return "ECDSA"
                case .ECDH: return "ECDH"
                }
            }
        }

        init(from data: UInt8) {
            self.algorithmID = AlgorithmAttributesID(rawValue: data)
        }

    }

    class AlgorithmAttributesRSA: AlgorithmAttributes, CustomStringConvertible {
        // Length of modulus n in bit (e. g. 2048 bit decimal = 0800), binary
        var modulusLength: UInt16? = nil

        // Length of public exponent e in bit (e. g. 32 bit decimal = 0020), binary
        var exponentLength: UInt16? = nil

        // Import-Format of private key
        var importFormat: AlgorithmAttributesRSAImportFormat? = nil

        enum AlgorithmAttributesRSAImportFormat: UInt8, CustomStringConvertible {
            case standard               = 0x00
            case standardWithModulus    = 0x01
            case crt                    = 0x02
            case crtWithModulus         = 0x03

            var description: String {
                switch self {
                case .standard: return "Standard (e, p, q)"
                case .standardWithModulus: return "Standard (e, p, q) with Modulus"
                case .crt: return "Chinese Remainder Theorem"
                case .crtWithModulus: return "Chinese Remainder Theorem with Modulus"
                }
            }
        }

        init(from data: Data) {
            super.init(from: UInt8(data[0]))

            modulusLength = (UInt16(data[1]) << 8) + UInt16(data[2])
            exponentLength = (UInt16(data[3]) << 8) + UInt16(data[4])
            importFormat = AlgorithmAttributesRSAImportFormat(rawValue: UInt8(data[5]))
        }

        var description: String {
            return """
            === AlgorithmAttributesRSA ===
            Modulus length: \(modulusLength?.description ?? "nA")
            Exponent length: \(exponentLength?.description ?? "nA")
            Import format: \(importFormat?.description ?? "nA")
            """
        }

    }

    class AlgorithAttributesECDSA: AlgorithmAttributes, CustomStringConvertible {
        // OID of relevant curve, binary (see annex)
        var oid: Data? = nil

        // Import-Format of private key  (optional)
        var importFormat: UInt8? = nil

        init(from data: Data) {
            super.init(from: UInt8(data[0]))

            importFormat = UInt8(data[data.count - 1]) // last byte
            oid = Data(data.dropFirst().dropLast()) // everything but ID and import format
        }

        var description: String {
            return """
            === AlgorithAttributesECDSA ===
            OID: \(oid?.description ?? "nA")
            Import format: \(importFormat?.description ?? "nA")
            """
        }
    }

}
